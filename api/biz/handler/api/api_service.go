// Code generated by hertz generator.

package api

import (
	"context"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/hertz-contrib/websocket"
	api "im-demo/api/biz/model/api"
	"im-demo/api/global"
	"im-demo/api/middleware"
	"im-demo/api/ws"
	"im-demo/kitex_gen/message"
	"im-demo/kitex_gen/user"
	"net/http"
	"sync"
)

// Login .
// @router /user/login [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.LoginRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp, err := global.UserClient.Login(ctx, &user.LoginRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	j := middleware.NewJWT()
	token, err := j.CreateToken(resp.Userid)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
	}

	c.JSON(consts.StatusOK, &api.LoginResponse{Token: token})
}

// Register .
// @router /user/register [POST]
func Register(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.RegisterRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp, err := global.UserClient.Register(ctx, &user.RegisterRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// AddFriend .
// @router /user/addfriend [POST]
func AddFriend(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.AddFriendRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	myId, _ := c.Get("uuid")
	resp, err := global.UserClient.AddFriend(ctx, &user.AddFriendRequest{
		MyId:     myId.(string),
		FriendId: req.Frienduuid,
	})
	if err != nil {
		c.String(http.StatusBadRequest, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// DelFriend .
// @router /user/delfriend [POST]
func DelFriend(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.DelFriendRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	myId, _ := c.Get("uuid")
	resp, err := global.UserClient.DeleteFriend(ctx, &user.DeleteFriendRequest{
		MyId:     myId.(string),
		FriendId: req.Frienduuid,
	})
	if err != nil {
		c.JSON(http.StatusBadRequest, err.Error())
	}

	c.JSON(consts.StatusOK, resp)
}

// WsChat .
// @router /wschat [GET]

// WsChat .
// @router /wschat [GET]
func WsChat(ctx context.Context, c *app.RequestContext) {
	uuid, _ := c.Get("uuid")
	err := global.Upgrader.Upgrade(c, func(conn *websocket.Conn) {
		client := &ws.Client{
			Uuid:    uuid.(string),
			Conn:    conn,
			Send:    make(chan []byte),
			Storage: make(chan message.SaveMsgRequset, 1),
		}
		global.Wg.Add(1)
		ws.MyServer.Register <- client
		go client.Read(uuid.(string))
		go client.Write()
		global.Wg.Wait()
	})
	if err != nil {
		hlog.Fatalf("upgrader websocket failed: %s", err.Error())
	}

	var locker sync.RWMutex

	go func() {
		for {
			locker.Lock()
			client, ok := ws.MyServer.Clients[uuid.(string)]
			locker.Unlock()
			if !ok {
				continue
			}

			savemessage := <-client.Storage
			global.MessageClient.SaveMessage(ctx, &savemessage)
		}
	}()

}
